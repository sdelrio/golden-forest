"use strict";(self.webpackChunkgolden_forest_website=self.webpackChunkgolden_forest_website||[]).push([[2376],{9137:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));n(1839);const o={},r="Docker build best practices",s={unversionedId:"Containers/Docker/docker-build",id:"Containers/Docker/docker-build",title:"Docker build best practices",description:"docker build builds an image from a Dockerfile.",source:"@site/docs/Containers/Docker/docker-build.md",sourceDirName:"Containers/Docker",slug:"/Containers/Docker/docker-build",permalink:"/docs/Containers/Docker/docker-build",draft:!1,editUrl:"https://github.com/sdelrio/golden-forest/edit/master/docs/Containers/Docker/docker-build.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Goodbye Docker Desktop",permalink:"/docs/Containers/Docker/docker-desktop-goodbye"},next:{title:"Docker Desktop for mac",permalink:"/docs/Containers/Docker/docker-mac"}},l={},d=[{value:"Don&#39;t run containers as root",id:"dont-run-containers-as-root",level:2},{value:"Don&#39;t use maintainer",id:"dont-use-maintainer",level:2},{value:"Avoid ENV where possible",id:"avoid-env-where-possible",level:2},{value:"Build with cache mount",id:"build-with-cache-mount",level:2},{value:"Use SSH agent",id:"use-ssh-agent",level:2},{value:"Use build secrets",id:"use-build-secrets",level:2},{value:"Use <code>ONBUILD</code> Commands in Images",id:"use-onbuild-commands-in-images",level:2},{value:"Articles",id:"articles",level:2}],c={toc:d},u="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"docker-build-best-practices"},"Docker build best practices"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"docker build")," builds an image from a Dockerfile."),(0,i.kt)("h2",{id:"dont-run-containers-as-root"},"Don't run containers as root"),(0,i.kt)("p",null,"Even though containers are theoretically isolated, it is not good security practice to run processes as root inside them in the same way as you don\u2019t run your web server as root."),(0,i.kt)("p",null,"Towards the end of your build you should add something like"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"RUN useradd app\nUSER app\n")),(0,i.kt)("h2",{id:"dont-use-maintainer"},"Don't use maintainer"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MAINTAINER")," is deprecated. Instead of"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"MAINTAINER myfullname (myuser@mydomain.com)\n")),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"LABEL"),"s instead so they can be inspected just like any other metadata."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},'LABEL maintainer="myfullname (myuser@mydomain.com)"\n')),(0,i.kt)("h2",{id:"avoid-env-where-possible"},"Avoid ENV where possible"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ENV")," variables remain in the container at run time and pollute its own environment. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"ARG"),"s instead."),(0,i.kt)("h2",{id:"build-with-cache-mount"},"Build with cache mount"),(0,i.kt)("p",null,"Speed up your builds by providing a cache for your package manager, ccache, git and so on. This needs to be enabled with DOCKER_CLI_EXPERIMENTAL=enabled"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"# syntax=docker/dockerfile:experimental\n# FROM and the rest\n\nRUN --mount=type=cache,target=/var/cache/apt --mount=type=cache,target=/var/lib/apt \\\n    apt-get install -y --no-install-recommends mongodb-server\n")),(0,i.kt)("h2",{id:"use-ssh-agent"},"Use SSH agent"),(0,i.kt)("p",null,"If you require SSH credentials for your build don\u2019t copy ~/.ssh because it will stay in the layer even if you remove it later.\nSet up SSH agent, and use the experimental feature for ssh mounts"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"RUN --mount=type=ssh git clone https://github.com/private_repo/repo.git\n")),(0,i.kt)("h2",{id:"use-build-secrets"},"Use build secrets"),(0,i.kt)("p",null,"If you need sensitive files that should not be public for your build, use secrets. This way, those files will only be visible to that ",(0,i.kt)("inlineCode",{parentName:"p"},"RUN")," command during its execution and its contents will disappear without a trace from all layers after that."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"RUN --mount=type=secret,id=signing_key,dst=/tmp/sign.cert signing_command\n")),(0,i.kt)("h2",{id:"use-onbuild-commands-in-images"},"Use ",(0,i.kt)("inlineCode",{parentName:"h2"},"ONBUILD")," Commands in Images"),(0,i.kt)("p",null," What this does is it specifies commands which are to be run when a new image is being built from the image with the ",(0,i.kt)("inlineCode",{parentName:"p"},"ONBUILD")," commands."),(0,i.kt)("p",null,"One way to think of it is as a form of inheritance for images and it can be very useful in reducing code duplication up your Dockerfiles. In fact, oftentimes Dockerfiles in your individual projects can be just a single ",(0,i.kt)("inlineCode",{parentName:"p"},"FROM")," command using your onbuild image. The one caveat to this is that you must have a standard set of build and run commands for all projects of that type."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Sample:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},'FROM node:8-alpine\n\nONBUILD CMD ["node", "/app/index.js"]\nONBUILD COPY package.json /appONBUILD\nRUN npm set progress=false && \\\n    npm install --silent\nONBUILD RUN npm test && \\\n    npm coverage\nONBUILD COPY . /app\n')),(0,i.kt)("p",null,"Now, say we build an image from the above Dockerfile and tag it as ",(0,i.kt)("inlineCode",{parentName:"p"},"theimage/node:8-onbuild")," and publish this image."),(0,i.kt)("p",null,"Then we can use this image for any Node.js project so long as it has the npm scripts for test and coverage and can be run from the file ",(0,i.kt)("inlineCode",{parentName:"p"},"index.js")," in the root of the project. The Dockerfile for our projects will be one line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"FROM theimage/node:8-onbluild\n")),(0,i.kt)("p",null,"And all of the logic will live in the shared image."),(0,i.kt)("p",null,"It is very beneficial for you and your organization to create and maintain common base images for all types of applications you plan to support and even create onbuild images off of these bases. This provides a good place to make sweeping changes, reduce the amount of code, and simplify your CI pipelines."),(0,i.kt)("h2",{id:"articles"},"Articles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://ownyourbits.com/2019/05/13/building-docker-containers-in-2019/"},"Building Docker containers in 2019")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://tech.cars.com/docker-for-continuous-delivery-advanced-topics-and-patterns-7532235998af"},"2017: Docker for CD: Advanced Topics and Patters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.docker.com/develop/develop-images/dockerfile_best-practices"},"Docker best practices"))))}p.isMDXComponent=!0}}]);